 
 Search: Angelfire Web by     
 

Sound on the Gameboy Advance
Day 1


After how many replies I've made on the GBADev forums about how to write sound mixers,
I've finally decided to write up an article series on them. 
I'll start out with the basics, just getting sounds to play and creating a good framework
to work off of, and work my way into writing a full fledged music player and delving into
the world of hardcore assembly optimizations (i.e. the fun part).

1. What is sound?
2. How is sound data stored on a computer?
3. The GBA sound hardware
4. Buffering your sounds




1. What is sound?

Sound is simply a vibration of the air. When you drop something, like a fork or a spoon,
it hits the floor and makes a clink sound, right? That's because the impact with the floor
causes the metal to vibrate back and forth at a very high speed (as well as bouncing the
whole object back into the air), and when the object vibrates, it causes the air around it
to vibrate in the same pattern. When those air molecules vibrate, they bump into other
nearby air molecules, which in turn bump into their neighbors, until all the air molecules
in the room are boncing back and forth. When those vibrating air molecules bump into your
eardrums, you hear a sound.



2. How is sound data stored on a computer?

The PCM sound data used by the GBA's sound chip is stored as a stream of signed binary numbers,
and is the same as a normal .wav file on your computer. These numbers represent the pressure of
the air, measured at constant intervals of time. For example, if you have an 8KHz, 8-bit .wav
file, each byte represents the air pressure measured 1/8000, or 0.000125 seconds apart. A value
of 0 means the air is still and silent. Positive and negative numbers represent high and low
air pressure relative to the silent level.
Now back on the physics side of all this, what we really care about is that sounds behave like
waves. Just imagine waves on the surface of a lake. When you toss a stone into the lake, it
makes rings that move outward. These rings are visible because the water is either raised up
or dipped down from the rest of the surface. Guess what? That's just like the high and low
air pressure differences of a sound wave. So what? They're rings in the water, and we already
have a .wav file with the sound waves recorded, so we don't care. Rightfully so, you can play
that .wav file on the GBA just like it is and it will sound fine. But what if you want to mix
2 .wav files together and play them on the same GBA sound channel at the same time? Then you
have to throw 2 stones into the lake and try to figure out what happens to the rings they make.
Well here it is: When the crests (high parts) of 2 waves run into eachother, they push up
even higher. When the troughs (low parts) run together, they dip down even deeper. When a crest
and a trough collide, they cancel out, going back to the original level of the water.
If you look at your .wav file again, you'll see a similarity between all this. The silent 0
value represents the water level of the lake, a positive number represents a crest, raised up
higher than the base level, and a negative number is dipped down from the base level. If 2
positive numbers run together, you get a bigger positive number. 2 negatives gives you a
more negative number, and a positive and negative will go back toward 0.
What mathematical operation does this behave like? Addition, that's what. All you have to do
to mix PCM samples is add them together.
However, we first need to learn how to play a single sound. Baby steps, you know?



3. The GBA sound hardware

The GBA has 2 direct sound channels, named A and B (note: this has nothing to do with the
Direct Sound portion of Microsoft's DirectX).
Each channel is fed by a 16 byte FIFO buffer, which you can send 4 bytes at a time to by
writing data to REG_SGFIFOA and REG_SGFIFOB. Now, your first impulse will likely be to set
up a timer interrupt to write to these registers every 1/8000 seconds (assuming you're
playing an 8000Hz sound). Actually that would be 1/2000, because you have to write 4 bytes
at a time to the register. I think you could even write 4 words all one after another to
fill up the full 16 byte buffer, meaning you'd only have to interrupt every 1/500 seconds,
but I haven't tried it myself. Still, that's a lot of interrupting, and you'll most likely
be playing at a much higher frequency than 8KHz when you get a mixer running.
So, to combat this problem, the engineers who designed the hardware added in special
features to the DMA controller to prevent the need for an interrupt altogether. DMA channels
1 and 2 have this special sound mode, which causes them to fire up and transfer 16 bytes of
data whenever the sound FIFO has played its last byte of data. Bits 12 and 13 set the DMA mode.
Mode 0 is just a regular DMA that fires off immediately, mode 1 causes it to wait until VBlank
occurs and then transfer, mode 2 is HBlank, and mode 3 is sound mode. Normally, you'll want
to use these settings for the sound DMA:

REG_DM1CNT_H = DMA_DEST_FIXED | DMA_REPEAT | DMA_WORD | DMA_MODE_FIFO | DMA_ENABLE;

Or in hex, 0xB640. With that, it will just keep on going forever until you stop it by unsetting
the enable bit (DMAxCNT are write only, so just zero the whole reg). You also need to set up a
timer to tell the FIFO how often to play a sample. The FIFO plays a sample every time the timer
overflows. The GBA's hardware timers run at the CPU frequency of 16.7MHz, so you need to figure
out how to make it overflow at the same frequency as the sound you're playing. If you look at
it like a word problem in math class, it becomes obvious: What is the number of CPU cycles per
sound sample played? The answer: CPU freq / sound freq.
But that only gives you the number of CPU cycles to wait between samples, not the timer value.
Since the timers are 16-bit, they overflow when they hit 65536, so all you have to do is subtract
the number of cycles to wait from 65536 and you have it. So, the final formula is:


REG_TM0D = 65536 - (16777216 / soundFreq);

Why timer 0? Because the sound hardware can only use timers 0 and 1, and I picked 0 because I wanted to :-)

Both hardware channels can use the same timer, so you can play stereo sounds without losing 2 timers.
They CAN'T use the same DMA though, so if you want stereo sound in your game, kiss both DMA 1 and 2 goodbye.
Anyway, to select which timer a sound channel uses, use REG_SOUNDCNT_H (sometimes called REG_SGCNT0_H).
Check GBATEK or the CowBite spec for details on the bits, but for reference, bit 10 is the sound A timer
selection, and bit 14 is sound B timer select. They are both the same, and independent of eachother,
so you could, for example, set bit 10 and clear bit 14 to use timer 1 for sound A and timer 0 for sound B.

Here is a normal setting for mono sound playing on sound A with timer 0:

REG_SOUNDCNT_H = SOUNDA_VOLUME_100 | SOUNDA_LOUT | SOUNDA_ROUT | SOUNDA_FIFORESET;

Or 0x0604. Then you have to set bit 7 of REG_SOUNDCNT_X (sometimes called REG_SGCNT1) to enable sound.
With that, you should be able to make a simple sound demo. You'll need to get some sound data to play though.
I don't know any good GBA-specific converter tools, but you can use some programs like GoldWave or CoolEdit
to save raw sound data and include that in your project however you like. So, to start it all up:

REG_SOUNDCNT_H = SOUNDA_VOLUME_100 | SOUNDA_LOUT | SOUNDA_ROUT | SOUNDA_FIFORESET;   // = 0x0604
REG_SOUNDCNT_X = SOUND_ENABLE;   // = 0x80
REG_TM0D = 65536 - (16777216 / soundFreq);
REG_TM1CNT = TIMER_ENABLE;   // = 0x80
REG_DM1SAD = (u32) soundDataAddr;
REG_DM1DAD = (u32) &(REG_SGFIFOA);
REG_DM1CNT_H = DMA_DEST_FIXED | DMA_REPEAT | DMA_WORD | DMA_MODE_FIFO | DMA_ENABLE;   // = 0xB640

The length of the DMA is ignored, so no need to bother setting it.
Now, that will keep on playing right past the end of your sound, through the rest of the data in your ROM,
and out into The Great Land of Lost Pointers. To stop it right at the end of your sound, you need some
way of keeping track of how long it's been since you started it, and then write 0 to REG_DM1CNT_H when
it's done. The easiest way is to set up a timer and cascade it with your sound timer. That way, it will
increment once every time a sample is played, and then you can set it to interrupt after your sample's length.

REG_TM1D = 65536 - sampleLength;
REG_TM1CNT = TIMER_CASCADE | TIMER_INTERRUPT | TIMER_ENABLE;

And set up the timer 1 interrupt function to set REG_DM1CNT_H to 0. Beware though, if you try to loop a
sound using this method, you can get clicks because the DMA transfers 16 bytes at a time, so the length of
your sound must be a multiple of 16. No worries though, you'll be scrapping this method right away anyhow.


4. Buffering your sounds

This is where it's at. How to build a framework upon which you will create your sound system.
As soon as this is done, your involvement with the GBA's hardware will be pretty much over,
and you can begin the ever-so-fun task of writing a sound mixer and music player.

The easiest kind of buffering for use on GBA is double buffering. With it, you have 2 distinct buffers,
each the same size, and use an interrupt to decide when to swap them out.
For now, we'll do it with a VBlank interrupt, because it's the safest.
Doing it on a timer means opening up possibilities of another interrupt happening first and delaying the swap,
causing a click. Now, timing to a VBlank interrupt will cause very frequent clicks if you're not careful.
Only a select few frequencies time out perfectly. Calculating them is based on the fact that the GBA's CPU
runs exactly 280896 cycles per frame. If you take an integer factor of that number for your timer overflow cycle,
then you get perfect timing and no clicks. Furthermore, the number must be a multiple of 16 to make it past the
16 byte DMA transfer dilemma. Here is the famous table of values that work:


      REG_TM0D                    frequency    buffer size
         |                            |            |
         V                            V            V

Timer = 62610 = 65536 - (16777216 /  5734), buf = 96
Timer = 63940 = 65536 - (16777216 / 10512), buf = 176
Timer = 64282 = 65536 - (16777216 / 13379), buf = 224
Timer = 64612 = 65536 - (16777216 / 18157), buf = 304
Timer = 64738 = 65536 - (16777216 / 21024), buf = 352
Timer = 64909 = 65536 - (16777216 / 26758), buf = 448
Timer = 65004 = 65536 - (16777216 / 31536), buf = 528
Timer = 65073 = 65536 - (16777216 / 36314), buf = 608
Timer = 65118 = 65536 - (16777216 / 40137), buf = 672
Timer = 65137 = 65536 - (16777216 / 42048), buf = 704
Timer = 65154 = 65536 - (16777216 / 43959), buf = 736

Not too beautifully formatted, but the info is there. The first value is what you actually set in REG_TM0D,
then there's the frequency, which is in Hz, and the last value is the number of samples per frame,
so you'll need 2 buffers, each that size, and swap them out.
A good average quality/speed tradeoff is 18157Hz with a buffer of 304 bytes, which uses a timer value of 64612.

Now you need a VBlank interrupt to swap the buffers. It should look something like this:

typedef struct _SOUND_VARS
{
   s8 *mixBufferBase;
   s8 *curMixBuffer;
   u32 mixBufferSize;
   u8 activeBuffer;

} SOUND_VARS;

SOUND_VARS soundVars;

void SndVSync()
{
   if(soundVars.activeBuffer == 1)	// buffer 1 just got over
   {
       // Start playing buffer 0
      REG_DM1CNT_H = 0;
      REG_DM1SAD = (u32)soundVars.mixBufferBase;
      REG_DM1CNT_H = 0xB640;

       // Set the current buffer pointer to the start of buffer 1
      soundVars.curMixBuffer = soundVars.mixBufferBase + soundVars.mixBufferSize;

      soundVars.activeBuffer = 0;
   }
   else	// buffer 0 just got over
   {
       // DMA points to buffer 1 already, so don't bother stopping and resetting it

       // Set the current buffer pointer to the start of buffer 0
      soundVars.curMixBuffer = soundVars.mixBufferBase;
      soundVars.activeBuffer = 1;
   }
}

New global structure to group all the sound variables into one big bunch.

Here's an explanation of its members:
mixBufferBase is the start of BOTH mixing buffers, which are placed back to back.
This makes it a little easier, because you only need one pointer,
and only have to swap buffers every other frame, because once buffer 0 has finished
playing, the DMA is pointing directly at buffer 1 already, so it would be silly to
stop it and set the address to where it already was.
soundVars.mixBufferSize is the buffer size from the table.
Assuming we're using 18157Hz, it would be 304 right here.
soundVars.curMixBuffer is where you'll be copying data into next.
It will not be played until next frame, so you have plenty of time to fill it.
soundVars.activeBuffer is just a flag to tell which buffer is which.
You could also just compare soundVars.curMixBuffer to soundVars.mixBufferBase,
or anything else you want, just as long as you know which buffer is being played
and which is safe to mix in.

So now you have a double buffer running. The next step is to fill it.

How do you do that? You copy. Here's a simple way to play a looping sound:


typedef struct _SOUND_CHANNEL
{
   s8 *data;   // pointer to the raw sound data in ROM
   u32 pos;    // current position in the data
   u32 length; // length of the whole sound

} SOUND_CHANNEL;

SOUND_CHANNEL channel;

void SoundMix()
{
   s32 i;

   for(i = 0; i < soundVars.mixBufferSize; i++)
   {
       // copy a sample
      soundVars.curMixBuffer[i] = channel.data[ channel.pos++ ];

       // loop the sound if it hits the end
      if(channel.pos >= channel.length)
      {
         channel.pos = 0;
      }
   }
}
Basically a memcpy. What's interesting is the new struct, SOUND_CHANNEL.
This code snippet assumes that it was initialized somewhere else, but it will be an important
part of your mixer, and should be designed specifically to be friendly to your code.
In the end it will have more members, you'll have a whole array of them, and you'll
add all the data[pos]'s together before storing them in the buffer. That may seem simple,
and it is, but there are a few hang ups that make things a little tricky (not to mention making it fast).

This concludes day 1 of the tutorial. Next up: Mixing sounds together, and resampling them to
play at different pitches, even though the double buffer is always running at the same frequency. See you there!


 
Sound on the Gameboy Advance
Day 2


Howdy, and welcome to day 2 of the sound tutorial. In day 1, we learned how to play sounds,
and how to set up a sound buffer system on the GBA. Today, we'll be putting that buffer
to use with a mixer capable of playing sounds at different volumes and frequencies.

1. Volume
2. Resampling
3. Mixing

Example project


1. Volume

This is a no-brainer, but still it deserves a word. Changing volume is done by a straight fixed-point multiply.

newSample = oldSample * volume / volumeLevels;
volumeLevels will of course be a multiple of 2, so we can use bitshifting to prevent the divide.
Practically all tracker music formats use 64 levels, so we will too.
Then the volume formula becomes:

newSample = oldSample * volume >> 6;
Much nicer. Customarily, you never boost a sound's amplitude higher than the original.
You can do it, but then you'll get overflow all over the place, unless your sample never goes
all the way up or down to the maximum values, and then you're wasting accuracy that could give
you a better quality sample. Amplifying a sound to use the full range is called normalizing,
and can be done with ModPlug tracker. Then you can set the volume back down to make it sound
like it did before, or set it to full volume and have it back up as high as you ever could
have without overflowing. Thus, volume higher than the original wouldn't do you much good.


2. Resampling

Also known as changing the pitch. If you've ever written a program to scale a bitmap,
you know how to do this. In fact, it's even easier here than on a bitmap,
because it's 1-dimensional.
To resample, you need to be able to advance more or less than a full sample at a time.
For example, to play a sound at half its original frequency, you advance 1/2 a sample for
each output sample in the buffer. To do this, you need to make your position
a fixed-point variable too.
You can get away with 8 bits for the fractional portion and 24 for the integer,
but you can get some slightly off-pitch notes due to the lack of accuracy.
I use 16.16 because it gives you plenty of accuracy, and is a nice even number,
but really, you probably wouldn't ever be able to tell any difference once you get past
12 bits or so, and it doesn't make any difference code-wise. The problem with higher accuracy
is that you have less range on your integer. For example, with 16.16, your integer can only
get up to 65535 before it overflows. Doesn't this limit the length of your sounds to 64K, you may ask?
Yes, but you can get around it. Instead of always keeping your data pointer set to the start of
the data, you add the integer portion of the position onto it every mixing session, and chop the
integer off the position.
That's a little more advanced though, so for the first example, we'll go in the middle and use a
12-bit fraction. That leaves 20 bits of integer, so you can have sounds up to 1MB,
which should be plenty most of the time.

Expanding on the example from last time, here's now to do a looping sound with resampling and volume:

typedef struct _SOUND_CHANNEL
{
   s8 *data;   // pointer to the raw sound data in ROM
   u32 pos;    // current position in the data (20.12 fixed-point)
   u32 inc;    // increment (20.12 fixed-point)
   u32 vol;    // volume (0-64, sort of 1.6 fixed-point)
   u32 length; // length of the whole sound (20.12 fixed-point)

} SOUND_CHANNEL;

SOUND_CHANNEL channel;

void SoundMix()
{
   s32 i;

   for(i = 0; i < soundVars.mixBufferSize; i++)
   {
       // copy a sample
      soundVars.curMixBuffer[i] = channel.data[ channel.pos>>12 ] * channel.vol >> 6;
      channel.pos += channel.inc;

       // loop the sound if it hits the end
      if(channel.pos >= channel.length)
      {
         channel.pos = 0;
      }
   }
}

Not too much different, but it can do a whole lot more. Don't worry about being stuck with a looping sound,
we'll deal with that in a minute. First, you need to know how to properly calculate the increment value.
To start off, we'll resample a sound to play at its original frequency, even though it's being mixed into
the 18157Hz double buffer. Say your sound is 8000Hz, which is a little less than half of 18157.
You need to know how many 8000Hz samples to advance for each 18157Hz sample. This is done by dividing the
original frequency by the new one, in this case 8000/18157. Of course, you want to convert to fixed point
before the division, so since we're using 12 bits of accuracy for now, that becomes (8000<<12)/18157 = 1804.
That's a little less than half of 1<<12 (4096), so we can see that our formula is correct.
We won't go into playing different notes yet, but incase you're curious, all you do is use a lookup table
and multiply the frequency by that.


3. Mixing
This is where 90% of your sound-related CPU time will be spent, and so, it needs to be well-optimized.
But before that, it needs to work. Here would also be a good time to talk about sounds ending and NOT looping.
The reason I always had the sound loop before was so you'd always have something to copy into the buffer.
If the sound ends, then you have to fill the buffer with zeroes. Not a big deal, but I didn't want to
clutter the examples with it. This becomes even more of a problem when you mix several channels.
You need to zero the whole buffer before filling it, so you don't have to worry about sounds ending.
If you go through a whole lot of hassle, you can get around filling it unless no sounds at all are
playing, but it's not worth the trouble.
Another thing about sounds ending is that you need some sort of a flag to tell if a channel is active or not.
Plenty of ways to go about this. Adding a var to the channel structure, adding a bitfield with one bit per
channel to the global sound vars structure, or my favorite, setting the channel's data pointer to 0.
You'll never be playing a sound from a null pointer, so you can safely use it as a marker for inactive channels.
This also makes things easier and ever so slightly faster, because you'd have to load and check a variable in
any of those cases, but then if the channel IS active, you already have the data pointer loaded, so you don't
have to load it again.
Then for looping sounds, you need to be able to set the loop position to somewhere else than the start of
the sound every time. Usually the first thought is to store the loop position and then do something like

if(channel.pos >= channel.length)
   channel.pos = channel.loopStart;
While that does sort of work, it is not correct, and will sound distorted if you have a very short loop.
When you're looping a sound, you want to make it seem like the looped part has just been copied and pasted past
the end forever. When you set the position directly to the loop start, you lose any fractional portion of the
position, and possibly even part of the integer if your increment is greater than 1 (that is, a fixed-point 1,
or 1<<12 for the example). It also causes probles with that idea I mentioned earlier of updating the
data pointer each frame. The solution is to instead store the LENGTH of the looped portion, and subtract
that from the position when you run over. The loop length is just channel.length - channel.loopStart.

if(channel.pos >= channel.length)
   channel.pos -= channel.loopLength;
Then another problem comes up. What if your increment is bigger than the loop length?
Each time you add the increment and then see that you're past the end of the sample, you subtract the loop
length only to discover that you're still past the end. Bad bad bad. Doesn't happen too often, but if you like
chip music, you'll be seeing a lot of very short loops, and it could happen. At the cost of a small bit of speed,
you can combat this problem by using a while loop rather than an if:

while(channel.pos >= channel.length)
   channel.pos -= channel.loopLength;
Then to further complicate things, you need a way of telling if a sound should stop or loop when it hits the end.
Again, my favorite is to use a special value in one of the existing variables. This time I say if loop length is 0,
then stop, otherwise loop. Logically you would never use a loop length of 0, because you wouldn't back up at all,
and so would play on past the end of your data.

Now to put this all together.
One last thing is that when mixing sounds, you can obviously overflow 8 bits, because if you happen to have 2
samples above 63, say both are 100, then you get 200, which when read back as a signed 8-bit number is -56.
Definitely not what you want, and will sound horrible. To combat this, you can either divide by the total
number of channels being mixed, so you know you'll never run over, or you can clip the output values back
to the range -128 to 127. Dividing is easier, but you lose volume, and therefore accuracy,
increasing the background noise. Clipping is more expensive CPU-wise, and can still cause noticable distortion
if you get a whole lot of channels going at once. Either way, you can speed the whole mixing process up a lot by
using an intermediate 16-bit buffer, and dealing with overflow at the end. That way you save a shift for every
sample for every channel. With 4 channels running, that's already 304*4, or 1216 cycles.
Not a whole lot, but certainly worth doing.
Here is the new mixer that supports up to 4 channels at a time, unoptimized and untested,
written right here in good old notepad:

typedef struct _SOUND_CHANNEL
{
   s8 *data;       // pointer to the raw sound data in ROM (0 for inactive channel)
   u32 pos;        // current position in the data (20.12 fixed-point)
   u32 inc;        // increment (20.12 fixed-point)
   u32 vol;        // volume (0-64, sort of 1.6 fixed-point)
   u32 length;     // length of the whole sound (20.12 fixed-point)
   u32 loopLength; // length of looped portion (20.12 fixed-point, 0 for no loop)

} SOUND_CHANNEL;

SOUND_CHANNEL channel[4];

void SoundMix()
{
   s32 i, curChn;
   s16 tempBuffer[304];

    // zero the buffer
   i = 0;
   Dma3(tempBuffer, &i, soundVars.mixBufferSize*sizeof(s16)/4, DMA_WORD | DMA_ENABLE);

   for(curChn = 0; curChn < 4; curChn++)
   {
      SOUND_CHANNEL *chnPtr = &channel[curChn];

       // check special active flag value
      if(chnPtr->data != 0)
      {
          // this channel is active, so mix its data into the intermediate buffer
         for(i = 0; i < soundVars.mixBufferSize; i++)
         {
             // mix a sample into the intermediate buffer
            tempBuffer[i] += chnPtr->data[ chnPtr->pos>>12 ] * chnPtr->vol;
            chnPtr->pos += chnPtr->inc;

             // loop the sound if it hits the end
            if(chnPtr->pos >= chnPtr->length)
            {
                // check special loop on/off flag value
               if(chnPtr->loopLength == 0)
               {
                   // disable the channel and break from the i loop
                  chnPtr->data = 0;
                  i = soundVars.mixBufferSize;
               }
               else
               {
                   // loop back
                  while(chnPtr->pos >= chnPtr->length)
                  {
                     chnPtr->pos -= chnPtr->loopLength;
                  }
               }
            }
         } // end for i = 0 to bufSize
      } // end data != 0
   } // end channel loop

    // now downsample the 16-bit buffer and copy it into the actual playing buffer
   for(i = 0; i < soundVars.mixBufferSize; i++)
   {
       // >>6 to divide off the volume, >>2 to divide by 4 channels to prevent overflow
      soundVars.curMixBuffer[i] = tempBuffer[i] >> 8;
   }
}
Lots of new ideas to absorb, but still, that's not a whole lot of code,
and it is a fully functional mixer.

Here is an example project putting everything we've done so far to use.
Mostly what you need to see are Sound.c/.h, Irq.c and Main.c.
Also, SndData.S is a raw sample, converted from Data\Piano.raw using b2x.
Piano.raw was converted from Data\Piano.wav by saving it as raw PCM data in CoolEdit.

This mixer is a little slow though. One way you can speed it up a little is by skipping
the check for wether the sound ended, unless you know it's actually going to be ending this frame.
To find out if it will be ending, do this:

if(chnPtr->pos + chnPtr->inc*soundVars.mixBufferSize >= chnPtr->length)
{
    // somewhere before the end of the mixing, this channel will pass the end, 
    // so do the loop as before, checking if it ends every sample
}
else
{
    // after inc gets added all 304 times, the position will still be less than 
    // the length, so there's absolutely no point in checking it every sample. 

    // New loop looks like this:

   for(i = 0; i < soundVars.mixBufferSize; i++)
   {
       // mix a sample into the intermediate buffer
      tempBuf[i] += chnPtr->data[ chnPtr->pos>>12 ] * chnPtr->vol;
      chnPtr->pos += chnPtr->inc;
   }
}
Right there you saved hundreds more cycles per channel in most cases.
Still, this algorithm itself is not that great.
Even if you write it in ASM, you will get very little speed improvement.
The real benefit of ASM is that you have a whole bunch of registers to play with,
and that allows you to use new algorithms that a compiler would not be able to
comprehend well enough to make fast. For now, we will use this mixer, and proceed
to writing a music player, cause that's what's coming your way next time in day 3. Stay tuned!


 
Sound on the Gameboy Advance
Day 3


I hope you brought a can of coding whup-ass, cause today we're going to tackle the
inconspicuously difficult task of writing a tool to convert MOD files into a more
usable format for a player on GBA.
While MOD is said to be one of the simplest of music formats, it has several hangups
about it that make our lives more difficult than they need to be. I normally argue
that Impulse Tracker is even easier (and every bit as functional) to write a player
for, as long as you strip out most of the advanced features, but after further
consideration, I would rather not expose you to the terror of writing a converter
tool for it right offhand.
MOD is much nicer to those who are new to sound programming, if you can get over
the little bumps of slightly scrambled-looking data. I will be going over the
important parts here, but I suggest you pick up a file called fmoddoc.txt for
reference, in the event that I leave out an important detail that gets you stuck. 
Google it, yo!

1. The MOD file

2. Loading the data
---Samples
---Orders
---Patterns
---Sample data


1. The MOD file

Before you can play a song, you need to know what kind of data you're dealing with.
It helps if you've written a MOD song before, or at least fiddled with a tracker at all.
ModPlug Tracker is my favorite, so you may want to check that out if you've never seen
how songs are organized.
First you have samples. These are just like .wav files, and can be any sort of sound you like.
These are what we will be playing our music with, just by playing them at different
frequencies to sound like different notes on a piano. In MOD, all samples are considered
to have their default frequency set to 8363Hz, or sometimes 8287Hz. Minor discrepancy caused
by the different VBlank rates of the NTSC and PAL Amiga computers that MOD files were
originally played on... We will assume that our sounds are all 8363Hz, and leave it at that.

Songs are stored as a series of patterns, which are like a big list of notes, samples, and
effects to be played. Patterns are layed out in columns and rows. Each column controls a
different mixer channel. Since we have 4 mixer channels, we will have 4 columns.
There are 64 rows in each pattern, and each row you can specify a note, sample or effect
to be procesed by the player. For now we will not worry about effects, because they are
tricky, and not necessary just to get some notes playing.
Notes are named just like on a piano, with C-2 being 'normal' frequency. ModPlug calls
C-5 middle, but really, it's supposed to be 2. No matter, because they don't have names
in the actual MOD file anyway.
When you play a note, it stops any other note that was playing on the same channel, and
starts the sample from the beginning. You can optionally specify a sample along with the
note in the pattern. If you don't specify a sample, it will use whichever was used last
on that channel. In most cases, samples and notes come in pairs.

Next, you need to know how to time things. There are 2 variables involved in this, speed
and tempo. Tempo is frequency at which we update our song. It is measured in BPM, which
is theoretically beats per minute, but it does't seem to really be. We'll just convert
to Hz and forget about it. Here is the formula to convert BPM to Hz:

songFreq = tempo*2/5;
We will ignore the fact that division is slow, because we won't be changing the tempo very
often anyway. The default tempo for MOD is 125 BPM, so 125*2/5 becomes 50Hz, or 50 ticks per second.
Next we have speed. Speed is the number of ticks per row, and the default is 6.
This means that rather than playing a new row 50 times per second, we wait 6 ticks,
play a row, wait 6 more, play a row... effectively playing rows at 50/6 (about 8.3) times per second.
Thus, with 64 rows per pattern, each pattern lasts about 8 seconds at the default speed.

One more level above patterns, you have orders. These are just what they sound like.
They specify the order to play the patterns in. One nice thing about tracked music is
that you can play the same pattern as many times as you want. This can save work and
space by recycling parts of a song that get repeated more than once. Of course, you can
just specify your orders like 1, 2, 3, 4, 5 and have one continuous song too.


2. Loading the data

If you're going to make a sound system, sooner or later you're going to have to
write yourself a tool to reformat the data into something more useful.
MOD in particular would be very ugly to try to play directly from the files you
have on your computer, and you would likely end up basically writing a converter
in your GBA game to deal with it. Instead, we'll do it all up front so it doesn't
slow things down when playing the game.

To begin with, we will open up a MOD file.
I like DOS for this sort of stuff, so we'll do something like this:

	// pass in one filename from the command line
zint main(int argc, char **argv)
{
	s32 i;
	FILE *modFile;

		// die if we didn't get a single argument (arg 0 is just the name 
		// of the program, arg 1 is the first real argument, so we should have 2)
	ASSERT(argc == 2);

		// assume the first argument was a valid filename
		// Note: "rb" means "read binary"
	modFile = fopen(argv[1], "rb");
		// die again if we couldn't open the file
	ASSERT(modFile);

		// we'll do stuff here in a minute

	fclose(modFile);

	return 0;
}
This also introduces a very handy thing, ASSERT. It is defined up top to be this:


#define ASSERT(cond)\
	if((cond) == FALSE) { \
		fprintf(stderr, "\nASSERT FAILED\n\t%s\n\tLine %i\n\n", __FILE__, __LINE__); \
		getch(); \
		exit(1); \
	}

This will simply tell you where the assert was called from, wait for you to press a key, and die. 

The first thing you want to do when reading a MOD file is to make sure it's a valid MOD and that
you know what to do with it. At position 1080, there is a 4-letter signature telling you what
kind it is. A normal 4-channel MOD should have the signature "M.K.". There are also signatures
like "6CHN" and "8CHN", specifying the number of channels. How you handle these is your own choice.
I first check for "M.K.", and if it's different, check if the last 3 chars are "CHN", and if so,
then read the first char as the number of channels. For now, we will bail out if we don't have 4
channels, so only accept "M.K." or "4CHN".

After that, we'll start from the start of the file and load everything in order. The first 20 bytes
are the song title. Any letters past the end of the name are set to NULL, but you are allowed to
use all 20, giving you a non-NULL terminated string. You can either make your name variable 21
chars and set the last to NULL, or just set name[19] to NULL, overwriting the last letter if
somebody made a name that long. This would also be a good place to create a new structure to
store all our song data:


typedef struct _MOD_HEADER
{
   char name[20];

} MOD_HEADER;
Then back down after the sig checking:


fseek(modFile, 0, SEEK_SET);
fread(modHeader.name, 20, 1, modFile);
modHeader.name[19] = '\0';	// chop that last letter, incase it's not already NULL
Samples
Immediately following the name is the sample information. This does not contain the actual
wave data, only the length/loop positions/etc. There are always 31 samples stored, wether
that many are used or not. The data is layed out like this:


22 bytes - Name
2 bytes  - Length
1 byte   - Fine tune
1 byte   - Volume
2 bytes  - Loop start
2 bytes  - Loop length
However, those 2-byte values (length, loop start and loop length) are stored in a funky way.
You have to convert them like this:


realVal = ((byte0<<8) | byte1) * 2;
Swap the bytes, and then multiply by 2. However, the multiply by 2 will overflow 16 bits if
the real length, for example, is greater than 65535 bytes. For now, we'll only swap the bytes,
and do the *2 in our music player later.
Here, you will need to create a sample structure to store the data. Something like this:


typedef struct _SAMPLE_HEADER
{
   char name[22];
   u16  length;
   u8   finetune;   // This will be explained when writing the music player
   u8   vol;
   u16  loopStart;
   u16  loopLength;

   s8   *smpData;   // This is stored at the end of the file and will be loaded later

} SAMPLE_HEADER;
We'll add an array of these to our header structure, load the samples, and swap the necessary bytes:


typedef struct _MOD_HEADER
{
   char name[20];
   SAMPLE_HEADER sample[31];

} MOD_HEADER;

/////////// Down in main:

for(i = 0; i < 31; i++)
{
   fread(&modHeader.sample[i], sizeof(SAMPLE_HEADER), 1, modFile);
   modHeader[i].smpData = NULL;   // Nothing for now, will load later

   modHeader.sample[i].length =     ( ((modHeader.sample[i].length & 0xff) << 8) | 
                                       (modHeader.sample[i].length >> 8) );

   modHeader.sample[i].loopStart =  ( ((modHeader.sample[i].loopStart & 0xff) << 8) | 
                                       (modHeader.sample[i].loopStart >> 8) );

   modHeader.sample[i].loopLength = ( ((modHeader.sample[i].loopLength & 0xff) << 8) | 
                                       (modHeader.sample[i].loopLength >> 8) );
}
Orders
After samples comes orders. The first byte is the number of orders in the song,
followed by an unused byte. After that is a straight 128 byte array of which patterns to play.
The length byte from before tells how many of these are actually used.
We'll add these into the header as well, and then load them.


typedef struct _MOD_HEADER
{
   char name[20];
   SAMPLE_HEADER sample[31];
   u8 order[128];
   u8 orderCount;

} MOD_HEADER;

//////////// Down in main:

fread(&modHeader.orderCount, 1, 1, modFile);

u8 trash;
fread(&trash, 1, 1, modFile);

fread(modHeader.order, 128, 1, modFile);
Nothing to it. Next we need to find out how many patterns to load. For some odd reason, whoever
designed the file format decided not to include this anywhere, but at the same time included a
totally wasted byte in the last section. So, we have to search through the orders and find the
highest pattern used for ourselves.


u8 highestPattern = 0;

for(i = 0; i < modHeader.orderCount; i++)
{
   if(modHeader.order[i] > highestPattern)
      highestPattern = modHeader.order[i];
}

   // we only found the highest pattern used, the number of them is one higher than that
modHeader.patternCount = highestPattern + 1;
Notice that I just added another variable, patternCount, to the MOD_HEADER struct.
Next, we will load the patterns themselves. But before that, we happen to be right back where
we started, position 1080, where the signature is (that "M.K." thing). No need to read it again,
so just jump over it.

Patterns
These are pretty tricky, but they're completely uncompressed here, which makes them far easier
to understand than most formats. The S3M/XM/IT formats all encode their patterns in different
ways to save space, and in fact, we will probably be encoding the MOD patterns ourselves later on,
but for now, we'll keep them uncompressed. Even so, we have to make some modifications to the data
for our player to use.

Pattern data it stored somewhat like a bitmap. Since we have 4 channels, it will be 4 columns wide.
Since all MOD patterns have 64 rows, it is 64 rows tall, so sort of a 4x64 array. Each cell is 4 bytes,
so the size of the whole pattern is 4*64*4, or 1024, which is 1KB.
Now here is why we want to reformat the data for our player. Each cell constains 4 fields,
a 12-bit period value, an 8-bit sample number, a 4-bit effect type, and an 8-bit effect parameter.
Now, you could organize these in a fairly simple way by storing the byte values on byte boundaries,
and just tacking the 4-bit one onto the top of the 12-bit one. But no, it's a hideous mess, and we
have to unscramble it. Here is how they are layed out:

   byte0    byte1     byte2    byte3
---------- -------- -------- ----------
| PPPPSSSS pppppppp EEEEssss FFFFFFFF |
---------- -------- -------- ----------
bit0.....7,0......7,0......7,0......7

Sample:    ssssSSSS
Period:    ppppppppPPPP
Effect:    EEEE
Parameter: FFFFFFFF
Taken from fmoddoc.txt, and rewritten in a way that I think makes it easier to understand
(going from lowest bit to highest bit as you read left to right).
If this looks backward to you, read the fmoddoc.txt one instead.
Now all we have to do now is shift those around to put them together like that.
It should look something like this:

u8 cell[4];
u8 sample;
u16 period;
u8 effect;
u8 param;

fread(cell, 4, 1, modFile);

sample = (cell[2] >> 4) | (cell[0] & 0xF0);
period = cell[1] | ((cell[0] & 0xF) << 8);
effect = cell[2] & 0xF;
param  = cell[3];
Now we have some data that we can actually use. But first, you must be wondering what
that period value is. That's what specifies what frequency the sample will be played at.
It's related to the Amiga's VBlank rate, and so makes little sense to us GBA people.

Here is the formula to convert from amiga period to Hz:

frequency = 7159090.5 / (period * 2);
We are not going to use periods at all, because they are a waste of space.
Instead, we will convert them to note numbers, and use a lookup table of frequencies for each note.
To do this, we need a table of period values for each note. Fortunately, fmoddoc.txt supplies one:

	dc.w 856,808,762,720,678,640,604,570,538,508,480,453 ; C-1 to B-1
	dc.w 428,404,381,360,339,320,302,285,269,254,240,226 ; C-2 to B-2
	dc.w 214,202,190,180,170,160,151,143,135,127,120,113 ; C-3 to B-3

So, right there you can see that the period for C-2, middle C, is 428.
Let's run this through our formula and see what we get:


frequency = 7159090.5 / (428 * 2);
frequency = 8363.42;
Remember earlier I said 8363 is the default frequency for all samples? This right here proves it.
Traditionally, MOD only has 3 octaves. However, because the period field is 12 bits,
there's no reason not to allow more. As you can see from the table, the period of octave 1 is
twice that of octave 2. C-2 is 428, and C-1 is 856. If you go down to C-0, you multiply it by 2
again and get 1712. This still fits in 4 bits, so it's ok. ModPlug actually lets you do this,
so we'll include support for it. Theoretically there's not much limit to how high pitched you
can go, but as you go higher, the periods get smaller, meaning you have less and less accuracy.
ModPlug lets you go up to B-4, so that's what we'll do too.
Next, we have to decide how to go about doing this. If you look closely at the table, you'll
see that some values in fact DON'T match up to exactly 2x eachother. For example, B-1 and B-2.
B-2 is 226, and B-1 is 453. But 226*2 is 452. We will take octave 1 and calculate everything
else based on it, because it has the highest accuracy to begin with.

Once we have a full 5-octave table, we need to compare the periods of the notes in the pattern
to it to decide what the note number should be. We'll declare note 0 to be C-0, note 1 to be C#0,
note 2 D-0, etc., then note 12 is C-1, note 24 is C-2, all the way up to 59 being B-4. As you can
see, our new note number only requires 6 bits to store, instead of the 12 in the original format.
So we'll start off by creating the full period table:

const u16 octave1Period[12] = {
      // this is the first row of the table from before
   856,808,762,720,678,640,604,570,538,508,480,453   // C-1 to B-1
};

   // 5 octaves' worth of space
u16 periodTable[12*5];
u8 octave, note;

for(octave = 0; octave < 5; octave++)
{
   for(note = 0; note < 12; note++)
   {
         // *2 to get us into octave 0, then divide by 2 for each octave up from there
      periodTable[octave*12 + note] = (octave1Period[note]*2) >> octave;
   }
}
Now we have a table of period values to compare our notes to.
Before we start converting our pattern data, we need to know how we plan to store it. Our note
values will take 6 bits as we saw before.
The sample number, while stored as a byte originally, only needs 5 bits. MOD files only support
31 samples, so no need to waste those extra 3 bits storing it as a byte.
The effect and parameter use all their bits, so we'll keep them like they are
(4 bits and 8 bits respectively). So, this comes out to 6+5+4+8 = 23 bits.
We just chopped a byte off each cell in our pattern, so the total size of each pattern is now
only 768 bytes, rather than 1024. The question though, is wether this savings is worth a little
extra complexity.
When you look at how the information will have to be stored, it will be something like this:

   byte0    byte1     byte2  
---------- -------- ----------
| NNNNNNss SSSxEEEE FFFFFFFF |
---------- -------- ----------
bit0.....7,0......7,0......7

Note:   NNNNNN
Sample: ssSSS
Effect: EEEE
Param:  FFFFFFFF
x: unused
As you can see, the note, effect and parameter are easy enough to extract, but the sample number
is spread over 2 bytes. This would not be a problem if we could just load those 2 bytes, shift the sample field down, and mask off the data above it. However, because the whole field is 3 bytes, we will no longer have any guaranteed power-of-two alignment, so we can only read single bytes at a time. We can still extract all the necessary information, it would just make our code a little ugly. For now, we will go the easy route and store each field as a whole byte, like this:

   byte0    byte1     byte2    byte3
---------- -------- -------- ----------
| NNNNNNxx SSSSSxxx EEEExxxx FFFFFFFF |
---------- -------- -------- ----------
bit0.....7,0......7,0......7,0......7

Much nicer. However, now that we have word alignment back, it would be easy to extract the packed
values, but it would be a waste of time when we can load them seperately to begin with. Sad.

Now we will add another variable to MOD_HEADER, and convert all the patterns to our new format:

typedef struct _MOD_HEADER
{
   char name[20];
   SAMPLE_HEADER sample[31];
   u8 order[128];
   u8 **pattern;
   u8 orderCount;
   u8 patternCount;

} MOD_HEADER;

//////////// Down in main:

modHeader.pattern = new u8*[modHeader.patternCount];
ASSERT( modHeader.pattern );   // handle running out of memory
   // Initialize the memory to 0
memset( modHeader.pattern, 0, modHeader.patternCount*sizeof(u8*) );

u8 curPattern, row, column;

for(curPattern = 0; curPattern < modHeader.patternCount; curPattern++);
{
      // Allocate the memory for our new pattern (they are always 1K)
   modHeader.pattern[curPattern] = new u8[1024];
   ASSERT( modHeader.pattern[curPattern] );   // handle running out of memory
   memset( modHeader.pattern[curPattern], 0, 1024);   // initialize to 0

   for(row = 0; row < 64; row++)
   {
      for(column = 0; column < 4; column++)
      {
///////////////////////////// Copy our bit of code from earlier
         u8 cell[4];
         u8 sample;
         u16 period;
         u8 effect;
         u8 param;

         fread(cell, 4, 1, modFile);

         sample = (cell[0] & 0xF0) | (cell[2] >> 4);
         period = cell[1] | ((cell[0] & 0xF) << 8);
         effect = cell[2] & 0xF;
         param  = cell[3];
//////////////////////////// end copied code

            // Now we'll loop through our note period table and find the closest match
         u8 closestNote = 0;
         u16 closestDist = 0xffff;   // make sure the first comparison sets the closest note

         for(i = 0; i < 12*5; i++)   // 5 octaves, 12 notes each
         {
            u16 newDist = abs( period - periodTable[i] );
            if(newDist < closestDist)
            {
               closestNote = i;
               closestDist = newDist;
            }
         }

            // Now that we have our note, we can store the data in our new pattern
            // Calculate the address of the cell to output to
            // rowOffset = row * 4 columns per row * 4 bytes per cell
            // columnOffset = column * 4 bytes per cell
         u8 *outCell = &modHeader.pattern[curPattern][row*4*4 + column*4];
         outCell[0] = closestNote;
         outCell[1] = sample;
         outCell[2] = effect;
         outCell[3] = param;
      }
   }
}
Sample data
Following the pattern data is the sample data. This is the raw wave data that we
never loaded before. These are layed out one after another like patterns.
The length of each one is stored in the sample structs that we loaded earlier.
The wave data is signed 8-bit, which is what our mixer uses, so all we have to
do is load it like it is. One point though, we need to remember that our length
variable is stored as half of the real length, because they wanted to allow samples > 64KB,
and we didn't want to waste 2 bytes per sample making it a u32 just for one more bit.


for(i = 0; i < 31; i++)
{
      // Compute the real length in bytes
   u32 realLength = ((u32)modHeader.sample[i].length) * 2;

   if(realLength != 0)
   {
      modHeader.sample[i].smpData = new s8[realLength];
      ASSERT(modHeader.sample[i].smpData != NULL);

      fread(modHeader.sample[i].smpData, realLength, 1, modFile);
   }
}
So, there you have it. We now have the entire MOD loaded and ready to output.
However, there's one small problem. This is only one MOD, and we want to load
a whole bunch of them, and remove duplicate samples and such. This will be
resolved next time in day 4 of the series when we finish up the converter program.

Today turned out to be a horrible mess just to load in a MOD file, and I kind of
regret spending so much time on it when fmoddoc.txt explains pretty much everything
I just did in significantly less space. Oh well, what's done is done and we must forage ahead.


